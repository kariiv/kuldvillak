<!DOCTYPE html>
<html lang="ee">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Kuldvillak</title>
  <meta name="description" content="Kuldvillak? Kas sina juba teadsid?" />
  <script type="text/javascript">
    const gameData = [
              {
                c: "Inimesed",
                qs: [
                  { p:100,q:"Kes on Eesti peaminister?",a:"Kes on Andrus Ansip"},
                  { p:200,q:"Kes mängis \"üksinda kodus\" Kevinit?",a:"Kes on Macauly Culkin"},
                  { p:300,q:"Üks maailma kulsaim paar, kes mängisid koos filmis?",a:"Kes on Brad Pitt ja Angelina Jolie"},
                  { p:400,q:"kes on Kanadast pärit kuulsaim popstaar?",a:"Kes on Justin Bieber"},
                  { p:500,q:"Mis saatest sai kuulsaks perekond Kardashian?",a:"Mis on \"keeping up with Kardashians\""},
                ]
              },{
                c: "Eesti",
                qs: [
                  { p:100,q:"Kas Eesti on eurovisioonil võitnud?",a:"Mis on Jah"},
                  { p:200,q:"Kes võitis \"Su nägu kõlab tuttavalt\" esimese hooaja?",a:"Kes on Evelin Võigemast"},
                  { p:300,q:"Kes võitis saate \"Su nägu kõlab tuttavalt\" teise hooaja?",a:"Kes on Koit Toome"},
                  { p:400,q:"Mitmes on Eesti maailmas nahavähi arvukuse poolest?",a:"Mis on esimene"},
                  { p:500,q:"Kes kuulutas Tallinna üheks ilusaimaks linnaks jõulude ajal?",a:"Kes on BBC"},
                ]
              },{
                c: "Maailm",
                qs: [
                  { p:100,q:"Mitu inimest on maakeral kokku?",a:"Mis on 7 miljardit"},
                  { p:200,q:"Briti kuulsaim poistebänd?",a:"Kes on One Directon"},
                  { p:300,q:"Mis riigi kuninganna on Elisabeth II?",a:"Mis on Inglismaa"},
                  { p:400,q:"Lõuna-Prantsusmaal asuv \"kuulsate ja rikaste kuurort\"?",a:"Mis on Saint Tropez"},
                  { p:500,q:"Mis riik on saapa kujuline?",a:"Mis on Itaalia"},
                ]
              },{
                c: "Planeedid",
                qs: [
                  { p:100,q:"Mitmes planeet on päikesest Maa?",a:"Mis on kolmas"},
                  { p:200,q:"Mis on päikesesüsteemis esimene planeet päikesest?",a:"Mis on Merkuur"},
                  { p:300,q:"Mis planeedist on inspireeritud Marsimehe vitamiinid?",a:"Mis on Marss"},
                  { p:400,q:"Mis oli selle planeedi nimi, mis eemaldati päikesesüsteemist?",a:"Mis on Pluuto"},
                  { p:500,q:"Miks on Merkuuril võimatu elada?",a:"Mis on, sest seal on liiga kuum"},
                ]
              },{
                c: "Varia",
                qs: [
                  { p:100,q:"Millal tuuakse jõuludel tuppa kuusepuu?",a:"Mis on 23. detsember"},
                  { p:200,q:"Kes on kirjutanud raamatu \"Leiutajateküla Lotte\"?",a:"Kes on Andrus Kivirähk"},
                  { p:300,q:"Mis on Austraalia pealinn?",a:"Mis on Canberra"},
                  { p:400,q:"Millest on tulnud jõuluvana välimus?",a:"Mis on Coca Cola reklaamist"},
                  { p:500,q:"Mitu kilomeetrit on Tallinnast Helsingisse?",a:"Mis on 76 km"},
                ]
              }
            ]
  </script>
  <style type="text/css">
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    html {
      font-family: sans-serif;
      line-height: 1.15;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      -ms-overflow-style: scrollbar;
      -webkit-tap-highlight-color: transparent;
    }

    article,
    aside,
    dialog,
    figcaption,
    figure,
    footer,
    header,
    hgroup,
    main,
    nav,
    section {
      display: block;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      font-size: 1rem;
      font-weight: 400;
      line-height: 1.5;
      color: #212529;
      text-align: left;
      background-color: #fff;
    }

    [tabindex="-1"]:focus {
      outline: 0 !important;
    }

    hr {
      box-sizing: content-box;
      height: 0;
      overflow: visible;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    p {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    abbr[title],
    abbr[data-original-title] {
      text-decoration: underline dotted;
      cursor: help;
      border-bottom: 0;
    }

    address {
      margin-bottom: 1rem;
      font-style: normal;
      line-height: inherit;
    }

    ol,
    ul,
    dl {
      margin-top: 0;
      margin-bottom: 1rem;
    }

    ol ol,
    ul ul,
    ol ul,
    ul ol {
      margin-bottom: 0;
    }

    dt {
      font-weight: 700;
    }

    dd {
      margin-bottom: .5rem;
      margin-left: 0;
    }

    blockquote {
      margin: 0 0 1rem;
    }

    dfn {
      font-style: italic;
    }

    b,
    strong {
      font-weight: bolder;
    }

    small {
      font-size: 80%;
    }

    sub,
    sup {
      position: relative;
      font-size: 75%;
      line-height: 0;
      vertical-align: baseline;
    }

    sub {
      bottom: -.25em;
    }

    sup {
      top: -.5em;
    }

    a {
      color: #007bff;
      text-decoration: none;
      background-color: transparent;
    }

    a:hover {
      color: #0056b3;
      text-decoration: underline;
    }

    a:not([href]):not([tabindex]) {
      color: inherit;
      text-decoration: none;
    }

    a:not([href]):not([tabindex]):focus,
    a:not([href]):not([tabindex]):hover {
      color: inherit;
      text-decoration: none;
    }

    a:not([href]):not([tabindex]):focus {
      outline: 0;
    }

    pre,
    code,
    kbd,
    samp {
      font-family: monospace, monospace;
      font-size: 1em;
    }

    pre {
      margin-top: 0;
      margin-bottom: 1rem;
      overflow: auto;
      -ms-overflow-style: scrollbar;
    }

    figure {
      margin: 0 0 1rem;
    }

    img {
      vertical-align: middle;
      border-style: none;
    }

    svg:not(:root) {
      overflow: hidden;
    }

    a,
    area,
    button,
    [role="button"],
    input:not([type="range"]),
    label,
    select,
    summary,
    textarea {
      -ms-touch-action: manipulation;
      touch-action: manipulation;
    }

    table {
      border-collapse: collapse;
    }

    caption {
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
      color: #868e96;
      text-align: left;
      caption-side: bottom;
    }

    th {
      text-align: inherit;
    }

    label {
      display: inline-block;
      margin-bottom: .5rem;
    }

    input,
    button,
    select,
    optgroup,
    textarea {
      margin: 0;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    button, input {
      overflow: visible;
    }

    button, select {
      text-transform: none;
    }

    button,
    html [type="button"],
    [type="reset"],
    [type="submit"] {
      -webkit-appearance: button;
    }

    button::-moz-focus-inner,
    [type="button"]::-moz-focus-inner,
    [type="reset"]::-moz-focus-inner,
    [type="submit"]::-moz-focus-inner {
      padding: 0;
      border-style: none;
    }

    input[type="radio"],
    input[type="checkbox"] {
      box-sizing: border-box;
      padding: 0;
    }

    input[type="date"],
    input[type="time"],
    input[type="datetime-local"],
    input[type="month"] {
      -webkit-appearance: listbox;
    }

    textarea {
      overflow: auto;
      resize: vertical;
    }

    fieldset {
      min-width: 0;
      padding: 0;
      margin: 0;
      border: 0;
    }

    legend {
      display: block;
      width: 100%;
      max-width: 100%;
      padding: 0;
      margin-bottom: .5rem;
      font-size: 1.5rem;
      line-height: inherit;
      color: inherit;
      white-space: normal;
    }

    progress {
      vertical-align: baseline;
    }

    [type="number"]::-webkit-inner-spin-button,
    [type="number"]::-webkit-outer-spin-button {
      height: auto;
    }

    [type="search"] {
      outline-offset: -2px;
      -webkit-appearance: none;
    }

    [type="search"]::-webkit-search-cancel-button,
    [type="search"]::-webkit-search-decoration {
      -webkit-appearance: none;
    }

    [hidden] {
      display: none !important;
    }

    /*# sourceMappingURL=bootstrap-reboot.css.map */

    html,
    body {
      overflow: hidden;
    }

    body {
      background-color: #2a3698;
      height: 100%;
      font-family: Verdana, Arial, Helvetica, sans-serif;
      overflow-y: hidden;
    }

    * {
      box-sizing: border-box;
    }

    input,
    textarea,
    select {
      display: block;
      font-family: Verdana, Arial, Helvetica, sans-serif;
      margin: auto;
    }

    h3 {
      font-size: 20px;
    }

    .modal-wrapper {
      background-color: rgba(0, 0, 0, .5);
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2;
      height: 100%;
      /* Todo: stupid safari */
    }

    .modal {
      position: relative;
      top: 50%;
      transform: translate(0%, -50%);
      z-index: 2;
      border-radius: 5px;
      background-color: #efefef;
      overflow: auto;
      max-height: calc(100% - 50px);
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }

    #teams {
      position: absolute;
      bottom: 0;
      text-align: center;
      left: 0;
      right: 0;
      z-index: 11;

      display: flex;
      justify-content: center;
    }

    #teams .team {
      display: inline-block;
      margin-left: 5px;
      margin-right: 5px;
      border: 1px solid white;
      padding: 5px;
      background-color: white;
      border-top-left-radius: 2px;
      border-top-right-radius: 2px;
    }

    #teams .name {
      border: none;
      border-bottom: 2px solid black;
      text-align: center;
      color: black;
      display: inline-block;
      white-space: nowrap;
      min-width: 100px;
      max-width: 100px;
      font-size: 20px;
      font-weight: 700;
    }

    #teams .points {
      background-color: #2a3698;
      text-align: center;
      color: #fff;
      border: none;
      min-width: 100px;
      max-width: 100px;
      font-size: 20px;
      font-weight: 700;
    }

    .pointer {
      user-select: none;
    }

    .pointer span {
      display: inline-block;
      width: 45%;
      color: white;
      font-size: 30px;
      line-height: 30px;
      cursor: pointer;
      background-color: white;
      font-family: monospace;
      font-weight: bold;
    }
    .pointer .plus {
      color: #2da94e;
    }
    .pointer .minus {
      color: #ff0000;
    }

    #gameplay {
      filter: blur(5px);
      transition: filter 0.15s ease-in-out;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }

    #fullscreen {
      display: none;
      margin-top: 20px;
    }
    #fullscreen, #windows {
      display: none;
    }
    #fullscreen, #mac {
      display: none;
    }

    #game-chooser {
      font-size: 2em;
      color: white;
      font-weight: 700;
      background-color: transparent;
      border: none;
      margin-bottom: 1rem;
    }
    #game-chooser option {
      color: black;
      font-weight: 700;
    }

    #team-chooser {
      font-size: 22px;
      display: inline-block;
      height: 40px;
      -webkit-appearance: menulist-button;
      max-width: 52px;
      text-align: center;
    }

    #options input[type='button'] {
      font-size: 22px;
      display: inline;
      height: 40px;
    }

    #options a {
      color: white;
      text-decoration: underline;
    }

    #options a:hover {
      text-decoration: none;
    }

    #reset-all {
      background: transparent;
      color: white;
      margin-left: 10px;
      font-size: 14px !important;
      height: auto !important;
      border: none;
    }

    #question-modal {
      transform-origin: top left;
    }

    #question-modal>div {
      flex-direction: row;
    }

    #modal-header {
      display: flex;
      padding: 5px;
      text-align: center;
      color: #fff;
      background-color: #151b4b;
      z-index: 3;
    }

    #modal-header>div {
      padding: 5px;
      text-align: center;
      flex: 1;
      align-items: center;
      justify-content: center;
      display: flex;
      max-width: 100%;
    }

    #modal-header>div>div {
      max-width: 100%;
    }

    .modal,
    .modal-body {
      background-color: transparent;
      color: #fff;
      text-align: center;
    }

    .modal-body .modal-inner {
      overflow: auto;
      padding-left: 20px;
      padding-right: 20px;
      flex: 1;
    }

    .modal-body {
      width: 100%;
      display: flex;
      align-items: center;
      padding-top: 20px;
      justify-content: center;
    }

    #question-title {
      font-weight: bold;
      padding-left: 10%;
      padding-right: 10%;
    }

    .question, .answer {
      margin: auto;
    }

    #answer-button,
    #continue-button {
      cursor: pointer;
    }

    #question-modal {
      background-color: #2a3698;
      border: 3px solid #ffff00;
      z-index: 10;
    }
    #question-modal .answer {
      opacity: 0;
      border-top: 3px dotted white;
      margin-top: 10px;
      padding-top: 10px;
      transition: max-height 2s ease, opacity 2s ease;
    }
    #question-modal .reveal {
      opacity: 1;
    }
    .expanded {
      transition: .5s all ease;
      border-width: 0;
    }

    kbd {
      -moz-border-radius: 3px;
      -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset;
      -webkit-border-radius: 3px;
      -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset;
      background-color: #f7f7f7;
      border: 1px solid #ccc;
      border-radius: 3px;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px #fff inset;
      color: #333;
      display: inline-block;
      font-family: Arial, Helvetica, sans-serif;
      line-height: 1.4;
      margin: 0 .1em;
      padding: .1em .6em;
      text-shadow: 0 1px 0 #fff;
    }

    #options {
      display: block;
    }

    #first-load a {
      color: #000;
    }

    .cell.points .cell-inner {
      font-weight: bold;
      user-select: none;
    }

    #menu-picker {
      background-color: #131844;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      line-height: 1.25;
      text-transform: uppercase;
      align-self: flex-end;
      padding: 10px 10px;
      border-right: 2px solid #fff;
      border-top: 2px solid #fff;
      margin-right: 10px;
      position: absolute;
      color: #fff;
      text-decoration: none;
      bottom: 0;
      opacity: 0.1;
      transition: opacity .1s ease-in-out;
      writing-mode: vertical-rl;
      text-orientation: upright;
      user-select: none;
    }

    #menu-picker:hover {
      cursor: pointer;
      opacity: 1;
    }

    .cell-inner p:last-child {
      margin-bottom: 0;
    }

    .grid {
      padding: 10px;
      background: linear-gradient(to top, #1d2675 0%, #2a3698 100%);
      position: relative;
      transition: .1s;
      z-index: 1;
      font-size: 12px;
      display: flex;
      height: 100vh;
      flex-direction: column;
    }

    .grid-row {
      display: flex;
      flex: 1;
    }

    .grid-cell {
      border: 2px solid black;
      overflow: hidden;
      position: relative;
      background-color: #2a3698;
      transition: .3s;
      flex: 1;
    }

    .grid-preview .grid-row .grid-cell:first-child {
      transform-origin: left center;
    }

    .grid-preview .grid-row .grid-cell:last-child {
      transform-origin: right center;
    }

    .grid-preview .grid-last-row .grid-cell {
      transform-origin: bottom center;
    }

    .grid-preview .grid-last-row .grid-cell:first-child {
      transform-origin: bottom left;
    }

    .grid-preview .grid-last-row .grid-cell:last-child {
      transform-origin: bottom right;
    }

    .grid-last-row {
      border-bottom: 2px solid black;
    }

    .grid-first-row {
      border-top: 2px solid black;
    }

    .grid-row-questions {
      border-left: 2px solid black;
      border-right: 2px solid black;
    }

    .grid-row-cats .grid-cell {
      border-color: transparent;
    }

    .cell-group {
      backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    .cell {
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: #fff;
      backface-visibility: hidden;
      perspective: 1000px;
      transform-style: preserve-3d;
      -webkit-perspective: 0;
      -webkit-backface-visibility: hidden;
      width: 100%;
      height: 100%;
    }

    .cell a:link,
    .cell a:visited,
    .cell a:hover {
      color: #ffffff;
    }

    .cell.back {
      transform: rotateY(180deg);
    }

    .cell.front {
      z-index: 2;
    }

    .cell.back,
    .cell.front {
      cursor: pointer;
      overflow: hidden;
    }

    .cell-group:hover {
      border-color: #ffff00;
    }

    .cell-group:hover .front {
      transform: rotateY(180deg);
    }

    .cell-group:hover .back {
      transform: rotateY(0deg);
    }

    .cell-group:hover .back,
    .cell-group:hover .front {
      border-color: yellow;
    }

    .cell-group:hover .back,
    .cell-group:hover .front {
      transition: .6s;
    }

    .cell-group.empty {
      pointer-events: none;
    }

    .cell-group.empty:hover {
      border-color: black;
      transform: none;
    }


    /* play mode */
    .points .front,
    .points .back {
      display: none;
    }

    .grid-play .cell-group {
      cursor: pointer;
    }

    .grid-play .cell-group:hover {
      background-color: rgba(255, 255, 255, .05);
    }

    .inert .cell-inner {
      opacity: .05;
    }

    .grid.grid-play {
      background: none;
    }
  </style>
</head>
<body>
  <div id="gameplay">
    <div class="grid grid-play">
    </div>

    <div id="teams">
        <div class="team" style="display:none">
          <h3 class="name" contenteditable="true">Team 1</h3>
          <h3 class="points" contenteditable="true">0</h3>
          <div class="pointer">
            <span class="plus">+</span>
            <span class="minus">-</span>
          </div>
        </div>
    </div>

    <div id="question-modal" class="modal-wrapper">
      <div id="modal-header">
        <div id="continue-button">
          <div>Continue <kbd>ESC</kbd></div>
        </div>
        <div id="question-title"></div>
        <div id="answer-button">
          <div>Correct Response <kbd>Spacebar</kbd></div>
        </div>
      </div>
      <div class="modal-body">
        <div class="modal-inner">
          <div class="question"></div>
          <div class="answer"></div>
        </div>
      </div>
    </div>

  </div>

  <span id="menu-picker">MENU</span>

  <div id="options" class="modal-wrapper">
    <div class="modal">
      <select id="game-chooser">
        <option value="g1364524">Kuldvillak</option>
        <option value="g13564311">BESTVillak</option>
        <option value="g12356315">EestiVillak</option>
        <option value="g126136136">Audi</option>
      </select>
      <label for="team-chooser">Teams:</label>
      <input type="number" id="team-chooser" value="0"/>
      <br>
      <input class="submit" type="button" id="submit" value="Start"/>
      <input type="button" id="reset-all" value="Reset"/>
      <p id="fullscreen">
        <span id="windows">Press <kbd>F11</kbd></span> <span id="mac">Select menu option <kbd>View &gt; Enter Fullscreen</kbd></span> for full-screen mode
      </p>
      <script>
        if (window.navigator.platform.indexOf("Mac") === 0) {
          document.getElementById("fullscreen").style.display = "block";
          document.getElementById("mac").style.display = "inline";
        } else if (window.navigator.platform.indexOf("Win") === 0) {
          document.getElementById("fullscreen").style.display = "block";
          document.getElementById("windows").style.display = "inline";
        }
      </script>
    </div>
  </div>
  <script type="text/javascript">
    const ESC = 27
    const SPACE = 32

    function b64en(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1)))
    }
    function b64de(str) {
      return decodeURIComponent(atob(str).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
    }

    const gameplayEl = document.getElementById("gameplay")
    const gridEl = document.querySelectorAll(".grid")[0];
    const optionsEl = document.getElementById("options")
    const teamChooserEl = document.getElementById("team-chooser")
    const gameChooserEl = document.getElementById("game-chooser")
    const teamsEl = document.getElementById("teams")

    const submitEl = document.getElementById("submit")
    const resetEl = document.getElementById("reset-all")

    const modalEl = document.getElementById("question-modal")
    const modalTitleEl = document.getElementById("question-title")

    const modalQuestionEl = modalEl.querySelectorAll(".question")[0]
    const modalAnswerEl = modalEl.querySelectorAll(".answer")[0]
    const modalBodyEl = modalEl.querySelectorAll('.modal-body')[0]
    const modalInnerEl = modalEl.querySelectorAll('.modal-inner')[0]

    class Question {
      constructor(question, answer, points) {
        this.question = question
        this.answer = answer
        this.points = points
        this._asked = false // make cell gray
        this.answeredBy = [];
        this.category = null;
      }
      setCategory(category) {
        this.category = category;
      }
      getCategory() {
        return this.category;
      }
      getQuestion() {
        return this.question;
      }
      getAnswer() {
        return this.answer;
      }
      getPoints() {
        return this.points;
      }
      isAsked() {
        return this._asked;
      }
      asked() {
        this._asked = true
      }
      answered(team) {
        this.answeredBy.push(team)
      }
      getState() {
        return {
          q:this.getQuestion(),
          a:this.getAnswer(),
          p:this.getPoints()
        }
      }
      hashCode() {
        let hash = 0;
        for (const chr of this.getQuestion() + this.getAnswer()) {
          hash  = ((hash << 5) - hash) + chr.charCodeAt(0);
          hash |= hash & hash; // Convert to 32bit integer
        }
        return "q" + hash.toString();
      }
    }

    class Category {
      constructor(name) {
        this.name = name;
        this.questions = [];
      }

      addQuestion(question) {
        question.setCategory(this)
        this.questions.push(question)
      }
      removeQuestion(question) {
        question.setCategory(null)
        this.questions.splice(this.questions.indexOf(question), 1)
      }
      getQuestions() {
        return this.questions;
      }
      getQuestionById(id) {
        for (const question of this.getQuestions())
          if (question.hashCode() === id) return question
        return null
      }
      getQuestion(i) {
        const qs = this.getQuestions()
        if (i + 1 > qs.length) return null
        return qs[i];
      }

      createQuestion(question, answer, points) {
        this.addQuestion(new Question(question, answer, points))
        return this;
      }
      getName() {
        return this.name
      }
      getState() {
        return {
          c: this.getName(),
          qs: this.getQuestions().map(q => q.getState())
        }
      }
      hashCode() {
        let hash = 0;
        for (const chr of this.getName()) {
          hash  = ((hash << 5) - hash) + chr.charCodeAt(0);
          hash |= 0; // Convert to 32bit integer
        }
        return "c" + hash.toString();
      }
    }

    class Team {
      constructor(name, points=0, active = true) {
        this.name = name
        this._active = active

        this.pointsManual = points ? [points, ] : []
        this.correct = []
        this.incorrect = []
      }
      addAnsweredQuestion(question, correct) {
        const inc = this.incorrect.indexOf(question)
        if (inc !== -1) this.incorrect.splice(inc, 1)
        const corr = this.correct.indexOf(question)
        if (corr !== -1) this.correct.splice(corr, 1)

        if (correct && inc === -1) this.correct.push(question)
        else if (!correct && corr === -1) this.incorrect.push(question)
      }
      setPoints(points) {
        if (!Number.isInteger(points)) throw new Error('Type must be integer')
        this.pointsManual.push(points - this.getPoints())
      }
      getPoints() {
        const correctPoints = this.correct.map(q => q.getPoints()).reduce((a,b) => a + b, 0);
        const incorrectPoints = this.incorrect.map(q => q.getPoints()).reduce((a,b) => a + b, 0);
        const manualPoints = this.pointsManual.reduce((a,b) => a + b, 0);
        return correctPoints - incorrectPoints + manualPoints;
      }
      setName(name) {
        console.log(name)
        this.name = name
      }
      getName() {
        return this.name
      }
      getStatus() {
        return this._active;
      }
      active() {
        this._active = true;
      }
      inactive() {
        this._active = false;
      }

      getState() {
        const state = {}
        state["name"] = this.getName()
        state["points"] = this.getPoints()
        return state
      }
      hashCode() {
        let hash = 0;
        for (const chr of this.getName()) {
          hash  = ((hash << 5) - hash) + chr.charCodeAt(0);
          hash |= 0; // Convert to 32bit integer
        }
        return "t" + hash.toString();
      }
    }

    class Kuldvillak {

      constructor(name) {
        this.name = name
        this.teams = []
        this.categories = []
        this.answeredQuestions = []
        this.lastQuestion = null
      }
      addAnsweredQuestion(question) {
        for (const q of this.answeredQuestions)
          if (q === question) return
        if (!question.isAsked()) return
        this.answeredQuestions.push(question)
      }
      getQuestion(id) {
        for (const cat of this.getCategories()) {
          const question = cat.getQuestionById(id)
          if (question) return question
        }
        return null
      }
      setLastQuestion(question) {
        this.lastQuestion = question;
      }
      getLastQuestion() {
        return this.lastQuestion;
      }
      addTeam(team) {
        this.teams.push(team)
      }
      removeTeam(team) {
        this.teams.splice(this.teams.indexOf(team), 1)
      }
      getTeams() {
        return this.teams;
      }

      addCategory(category) {
        this.categories.push(category)
      }
      removeCategory(category) {
        this.categories.splice(this.categories.indexOf(category), 1)
      }
      getCategories() {
        return this.categories;
      }
      loadData(data) {
        for (const cat of data) {
          const c = new Category(cat.c)
          for (const q of cat.qs)
            c.addQuestion(new Question(q.q, q.a, q.p))
          this.addCategory(c)
        }
      }
      loadState(data) {
        const {id, teams, inerts, c} = data;
        this.loadData(c)
        if (this.hashCode() !== id) throw new Error("State not belong to this game")
        for (const inert of inerts) {
          const q = this.getQuestion(inert)
          q.asked()
          this.addAnsweredQuestion(q)
        }
        for (const team of teams)
          this.addTeam(new Team(team.name, team.points))
      }

      getName() {
        return this.name;
      }

      getState() {
        const state = {}
        state["id"] = this.hashCode()
        state["name"] = this.getName();
        state["teams"] = this.getTeams().map(t => t.getState());
        state["inerts"] = this.answeredQuestions.map(q => q.hashCode())
        state["c"] = this.getCategories().map(c => c.getState())
        return state
      }

      hashCode() {
        let hash = 0;
        for (const chr of this.getName()) {
          hash  = ((hash << 5) - hash) + chr.charCodeAt(0);
          hash |= 0; // Convert to 32bit integer
        }
        return "g" + hash.toString();
      }
    }

    const ListenerBuilder = function (prototype) {
      prototype.listeners = {}
      prototype.on = function (event, handler) {
        if (event in this.listeners) this.listeners[event].push(handler)
        else this.listeners[event] = [handler, ]
      }
      prototype.emit = function (event) {
        for (const handler of this.listeners[event]) handler(this)
      }
      prototype.addListener = function (func, listener) {
        const originalFunctionName = "old_" + func.name // Rename original function
        prototype[originalFunctionName] = func

        if (!(listener in prototype.listeners)) // Add listener key
          prototype.listeners[listener] = []
          prototype[func.name] = function (...args) { // Run old and then listener
          this[originalFunctionName](...args)
          this.emit(listener)
        }
      }
    }

    ListenerBuilder(Question.prototype)
    ListenerBuilder(Category.prototype)
    ListenerBuilder(Team.prototype)
    ListenerBuilder(Kuldvillak.prototype)

    Kuldvillak.prototype.addListener(Kuldvillak.prototype.addCategory, "category")
    Kuldvillak.prototype.addListener(Kuldvillak.prototype.removeCategory, "category")

    Kuldvillak.prototype.addListener(Kuldvillak.prototype.addTeam, "team")
    Kuldvillak.prototype.addListener(Kuldvillak.prototype.removeTeam, "team")

    Team.prototype.addListener(Team.prototype.setPoints, "points")
    Team.prototype.addListener(Team.prototype.active, "status")

    Category.prototype.addListener(Category.prototype.addQuestion, "question")
    Category.prototype.addListener(Category.prototype.removeQuestion, "question")

    Question.prototype.addListener(Question.prototype.asked, "asked")
    Question.prototype.addListener(Question.prototype.answered, "answered")

    function createElement(el, className, parentEl, innerText) {
      const El = document.createElement(el)
      if (className) El.className = className;
      if (innerText && el !== "input") El.innerText = innerText;
      if (innerText && el === "input") El.value = innerText;
      if (parentEl) parentEl.appendChild(El);
      return El;
    }

    function createTeamTab(team) {
      if (!team.getStatus()) return null
      const teamEl = createElement("div", "team", teamsEl);
      const nameEl = createElement("input", "name", teamEl, team.getName());
      const pointsEl = createElement("input", "points", teamEl, team.getPoints().toString());
      const pointerEl = createElement("div", "pointer", teamEl);
      const plusEl = createElement("span", "plus", pointerEl, "+");
      const minusEl = createElement("span", "minus", pointerEl, "-");
      plusEl.onclick = () => {
        const last = getCurrentGame().getLastQuestion()
        if (last) {
          team.addAnsweredQuestion(last, true)
          pointsEl.value = team.getPoints().toString()
          saveState()
        }
      }
      minusEl.onclick = () => {
        const last = getCurrentGame().getLastQuestion()
        if (last) {
          team.addAnsweredQuestion(last, false)
          pointsEl.value = team.getPoints().toString()
          saveState()
        }
      }
      nameEl.onchange = (e) => {
        team.setName(e.target.value)
        saveState()
      }

      pointsEl.onchange = (e) => {
        try{
          team.setPoints(parseInt(e.target.value))
          e.target.value = team.getPoints()
          saveState()
        } catch (err) {
          alert("Input must be integer!")
          e.target.value = team.getPoints()
        }
      }
      pointsEl.type = 'text'
      nameEl.type = 'text'
      return teamEl
    }
    function createCategoryCell(c) {
      const catEl = createElement("div", "grid-cell")
      const cellEl = createElement("div", "cell", catEl)
      createElement("div", "cell-inner cat-cell", cellEl, c)
      return catEl
    }
    function createQuestionCell(id, q, a, p, inerts) {
      const questionEl = createElement("div", "cell-group grid-cell" + (inerts? " inert": ''))
      const cellEl = createElement("div", "cell points", questionEl)
      createElement("div", "cell-inner", cellEl, p)
      createElement("div", "front question", cellEl, q)
      createElement("div", "back answer", cellEl, a)
      questionEl.id = id
      return questionEl
    }
    function createEmptyCell() {
      return createElement("div", "cell-group grid-cell empty");
    }

    function renderGrid(game) {
      gridEl.innerHTML = ''
      const categories = game.getCategories();
      const maxQuestions = Math.max(...categories.map(c => c.getQuestions().length));

      for (let i = 0; i <= maxQuestions; i++) {
        let className;
        switch (i) {
          case 0: // Categories
            className = "grid-row grid-row-cats"; break;
          case 1: // Questions first line
            className = "grid-row grid-row-questions grid-first-row"; break;
          case maxQuestions: // Questions last line
            className = "grid-row grid-row-questions grid-last-row"; break;
          default:
            className = "grid-row grid-row-questions"
        }

        const gridRowEl = createElement('div', className, gridEl);

        for (let j = 0; j < categories.length; j++) {
          let cellEl;
          const category = categories[j];
          if (i === 0) { // Category
            cellEl = createCategoryCell(category.getName());
          } else { // Question
            const q = category.getQuestion(i - 1);
            if (q) {
              cellEl = createQuestionCell(q.hashCode(), q.getQuestion(), q.getAnswer(), q.getPoints(), q.isAsked());
              cellEl.onclick = () => {
                getCurrentGame().setLastQuestion(q)
                renderState({ "page": "slide", "cell": q.hashCode() })
              }
            } else
              cellEl = createEmptyCell();
          }
          cellEl.setAttribute('data-row', i.toString());
          cellEl.setAttribute('data-col', j.toString());
          gridRowEl.appendChild(cellEl)
        }
      }
    }

    function removeClass(selector, cls) {
      for (const el of document.querySelectorAll(selector))
        el.classList.remove(cls);
    }

    function debounce(func, wait, immediate) {
      let timeout;
      if (immediate) return func
      return () => {clearTimeout(timeout);timeout=setTimeout(func, wait)};
    }

    function on(eventName, elementSelector, handler, extra) {
      document.addEventListener(eventName, function(e) {
        // loop parent nodes from the target to the delegation node
        for (let target = e.target; target && target !== this; target = target.parentNode) {
          if (matches(target, elementSelector)) {
            handler.call(target, e);
            break;
          }
        }
      }, extra || false);
    }

    function ready(fn) {
      if (document.readyState !== 'loading' && document.body) fn();
      else document.addEventListener('DOMContentLoaded', fn);
    }

    const game = {
      game: null
    }
    initial_state = { "page": "menu" }

    function loadGame(key) {
      const state = getState(key)
      let _game;
      if (state) {
        const {name} = state
        _game = new Kuldvillak(name)
        _game.loadState(state)
      }
      else {
        _game = new Kuldvillak('Kuldvillak')
        _game.loadData(gameData)
      }

      setCurrentGame(_game)
      return _game
    }

    function getCurrentGame() {
      return game.game;
    }
    function setCurrentGame(_game) {
      game.game = _game
    }

    function clearState() {
      const state = getState()
      if (state) {
        state["teams"] = []
        state["inerts"] = []
        localStorage.setItem(state.id, JSON.stringify(state))
        newReady()
      }
    }
    function getState(key) {
      const state = localStorage.getItem(key? key : getCurrentGame().hashCode())
      return state ? JSON.parse(state) : null;
    }
    function saveState() {
      const _game = getCurrentGame()
      localStorage.setItem(_game.hashCode(), JSON.stringify(_game.getState()))
    }

    window.addEventListener("resize", debounce(resize, 40, false));

    const newReady = function() {

      const _game = loadGame("g-1592841761")

      renderGrid(_game)
      resize()
      renderState(initial_state)
    }
    ready(newReady)

    function renderMenu() {
      const old_state = getState()
      optionsEl.style.display = "block";
      if (!old_state || (!old_state.teams.length && !old_state.inerts.length)) {
        submitEl.value = "Start";
        resetEl.style.display = "none";
        teamChooserEl.value = 2; // DEFAULT VALUE
      } else {
        submitEl.value = "Continue"
        resetEl.style.display = ""
        teamChooserEl.value = old_state.teams.length;
      }
    }
    function renderState(state) {
      if (state)
        history.pushState(state, "Game");
      else
        state = window.history.state

      optionsEl.style.display = "none";
      teamsEl.style.display = "none";
      gameplayEl.style.filter = "";

      modal.is_open = false;
      modalEl.style.display = "none";
      modalEl.classList.remove("expanded");
      modalEl.style.borderWidth = "3px";

      if (state.page === "menu") {
        renderMenu();
      } else {
        teamsEl.style.display = "flex";
        gameplayEl.style.filter = "blur(0px)";
        if (state.page === "slide")
          modal.show(getCurrentGame().getQuestion(state.cell), true);
      }
    }
    window.onpopstate = () => renderState();

    const shrink_cell_cache = {};
    let enable_caching = true;

    function shrink_cell($cell, $scaler, max_width, max_height, max_font_size, transforms) {
      let cached;
      let cache_key;
      if (enable_caching) {
        cache_key = [max_width, max_height, $cell.innerHTML].join(".");
        cached = shrink_cell_cache[cache_key];
      } else
        return _shrink_cell($cell, $scaler, max_width, max_height, max_font_size, transforms);

      if (cached) {
        $scaler.style.fontSize = cached.font_size + "px";
        $scaler.style.transform = (transforms || "") + " scale(" + cached.scale + ") ";
      } else
        shrink_cell_cache[cache_key] = _shrink_cell($cell, $scaler, max_width, max_height, max_font_size, transforms);
    }

    function shrink_in_place(max_font_size, min_font_size) {
      const a = { length: max_font_size + 1 }
      let font_size = binarySearch(a, (el, array, font_size) => {
        modalInnerEl.style.fontSize = font_size + "px";
        const isHorizontalScrollbar = modalInnerEl.scrollWidth > modalInnerEl.clientWidth;
        const isVerticalScrollbar = modalInnerEl.scrollHeight > modalInnerEl.clientHeight;
        return isHorizontalScrollbar || isVerticalScrollbar
      });
      font_size = font_size - 1
      font_size = Math.max(min_font_size, Math.min(font_size, max_font_size));
      modalInnerEl.style.fontSize = font_size + "px";
      return font_size;
    }

    function binarySearch(array, pred) {
      let lo = -1, hi = array.length;
      while (1 + lo < hi) {
        const mi = lo + ((hi - lo) >> 1);
        if (pred(array[mi], array, mi)) hi = mi;
        else lo = mi;
      }
      return hi;
    }

    function _shrink_cell($cell, $scaler, max_width, max_height, max_font_size, transforms, min_font_size) {
      if (min_font_size === undefined)
        min_font_size = 1;

      let font_size = Math.max(min_font_size, max_font_size);

      if (!$scaler) return { font_size: font_size }

      $cell.style.fontSize = "";
      $scaler.style.fontSize = font_size + "px";
      $scaler.style.transform = "";

      const extra_width = 0
      const extra_height = 0

      const bbox = getBoundingClientRect($scaler);
      const w = bbox.width;
      const h = bbox.height;
      const scale = Math.min(1, Math.min((max_width - extra_width) / w, (max_height - extra_height) / h));
      if (scale !== 1) {
        //debugger;
      }
      $scaler.style.transform = (transforms || "") + " scale(" + scale + ") ";

      return { font_size: font_size, scale: scale };
    }

    function getBoundingClientRect(el) {
      const bbox = el.getBoundingClientRect();

      return {
        top: bbox.top + (window.scrollY || document.documentElement.scrollTop || 0),
        left: bbox.left + (window.scrollX || document.documentElement.scrollLeft || 0),
        width: bbox.width,
        height: bbox.height,
        x: bbox.x,
        y: bbox.y
      }
    }

    function matches(el, selector) {
      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
    }

    function prepwork(cell, scale_factor) {
      if (scale_factor === undefined) scale_factor = 1;

      const width = cell.parentElement.clientWidth;
      const height = cell.parentElement.clientHeight;
      const inner = cell.querySelectorAll(".cell-inner")[0];

      shrink_cell(cell, inner, width * scale_factor, height * scale_factor, 32, "");
      return inner
    }

    function minirender(grid, question_scale_factor) {
      if (question_scale_factor === undefined)
        question_scale_factor = 1;

      miniresize(grid, grid.querySelectorAll(".grid-row-cats .cell"), true, 1);
      miniresize(grid, grid.querySelectorAll(".grid-row-questions .cell"), false, question_scale_factor);
    }

    function miniresize(grid, cells, is_cats, scale_factor) {
      if (is_cats) {
        const cat = grid.querySelectorAll(".grid-row-cats")[0]
        cat.style.height = "auto";
        let max_height = 0;
        for (const cell of cells) {
          const inner = prepwork(cell);
          cell.client_height = inner.clientHeight;
          max_height = Math.max(max_height, inner.clientHeight);
        }
        cat.style.height = max_height + "px";
      } else
        for (const cell of cells)
          prepwork(cell, scale_factor)
    }

    function resize() {
      let bbox_teams = getBoundingClientRect(teamsEl)
      let rows = document.querySelectorAll(".grid-row").length;
      let h;
      if (bbox_teams.height === 0) h = window.innerHeight;
      else h = bbox_teams.top + ((window.innerHeight - bbox_teams.height) / (rows)) / 4

      gridEl.style.height = h + "px";
      minirender(gridEl, .8);
    }

    game.init = function() {
      let val = parseInt(teamChooserEl.value)

      const _game = getCurrentGame()
      const teams = _game.getTeams()

      teamsEl.innerHTML = ''

      if (val < teams.length) {
        for (let i = val - 1; i < val; i++)
          _game.getTeams()[i].inactive()
      } else if (val > teams.length) {
        for (let i = teams.length; i < val; i++)
          _game.addTeam(new Team("Team " + (i + 1), 0))
      }
      for (let i = 0; i < val; i++) {
        const team = _game.getTeams()[i]
        team.active()
        createTeamTab(team)
      }
      saveState()
      renderState({ "page": "game" })
      resize()
    }

    let modal = function() {}
    modal.hide = function () {
      modalAnswerEl.classList.remove("reveal");
      renderState({ "page": "game" });
    }
    modal.reveal = function() {
      modalAnswerEl.classList.add("reveal");
      const _game = getCurrentGame()
      const question = _game.getLastQuestion()
      question.asked()
      _game.addAnsweredQuestion(question)
      document.getElementById(question.hashCode()).classList.add("inert");
      saveState()
    }
    modal.show = function(question) {
      modalTitleEl.innerText = question.getCategory().getName() + " " + question.getPoints()

      const questionEl = document.getElementById(question.hashCode())
      let bbox = questionEl.getBoundingClientRect();

      modalEl.style.display = "block";
      modalEl.style.opacity = "0";

      let position_of_top = getBoundingClientRect(modalBodyEl).top;
      let position_of_bottom = getBoundingClientRect(teamsEl).top || window.innerHeight;
      let h = position_of_bottom - position_of_top - 20 // 20 pixels for some extra room

      modalBodyEl.style.maxHeight = h + "px";
      modalInnerEl.style.height = h + "px";

      modalQuestionEl.innerText = question.getQuestion()
      modalAnswerEl.innerText = question.getAnswer()
      shrink_in_place(100, 24);

      modalEl.style.transform = `translate(${bbox.left}px, ${bbox.top}px) scale(${bbox.width / window.innerWidth}, ${bbox.height / window.innerHeight})`
      modalEl.style.opacity = "1";

      removeClass(".expanded", "expanded");
      setTimeout(() => {
        modalEl.classList.add("expanded");
        modalEl.style.top = "0";
        modalEl.style.left = "0";
        modalEl.style.bottom = "0";
        modalEl.style.right = "0";
        modalEl.style.width = "100%";
        modalEl.style.height = "100%";
        modalEl.style.borderWidth = "0";
        modalEl.style.transform = "translate(0px, 0px) scale(1)"
      }, 1);
      modal.is_open = true; // flag for the keyboard event
    }

    on("click", "#answer-button", () => modal.reveal());
    on("click", "#continue-button", () => modal.hide());
    on("click", "#menu-picker", () => renderState({ "page": "menu" }));
    on("click", "#submit", () => game.init());
    on("click", "#reset-all", (e) => {
      if (confirm("This will clear the scores and team names, and start a new game. Click OK if you want to do this"))
        clearState();
    });

    window.addEventListener("keydown", (e) => {
      if (modal.is_open) {
        if (e.keyCode === ESC) {
          e.preventDefault();
          modal.hide();
        } else if (e.keyCode === SPACE) {
          e.preventDefault();
          modal.reveal();
        }
      }
    }, false);
  </script>
</body>
</html>



